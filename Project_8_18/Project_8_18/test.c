#define _CRT_SECURE_NO_WARNINGS
//（1）int(*p)[4]它表示p是一个指针数组，它包含4个指针变量元素。(1分)
//（）T （）F
//答案：F
//分析：int(*p)[4]，定义一个数组指针，该指针指向含4个元素的一维数组（数组中每个元素是int型）。
//
//（2）结构体类型本身不占用内存空间，结构体变量占用内存空间。(1分)
//（）T （）F
//答案：T
//分析：结构体类型类似int类型，它们本身不占用内存空间，结构体变量相当于一个int类型的变量a，它们都会占用内存空间。
//
//（3）在定义嵌套的结构类型时，必须先定义成员的结构类型，再定义主结构类型。(1分)
//（）T （）F
//答案：T
//分析：类比其他常用的数据类型，只不过结构类型需要我们定义类型名和成员类型。
//
//选择题
//（5）若变量已正确定义并且指针p已经指向某个变量x，则(*p)++相当于___。(2分)
//A、p++
//B、x++
//C、*(p++)
//D、&x++
//答案：B
//分析：（*p）++，考虑运算符等级，先取 *p，然后把 *p的值 + 1。
//
//（6）对于以下结构定义，++p->str中的++加在___。(2分)
//struct {
//	int len;
//	char *str;
//} *p;
//A、指针str上
//B、指针p上
//C、str指的内容上
//D、以上均不是
//答案：A
//分析：->的等级大于++的等级，所以先p->str，然后 + 1。
//
//结构体链表纠错
//判断题
//（1）单向链表中的每个结点都需要动态分配内存空间。(1分)
//（）T （）F
//答案：T
//分析：因为使用动态分配内存空间可以及时分配储存空间，不象数组等静态内存分配方法那样需要预先分配存储空间
//
//（2）通常使用结构的嵌套来定义单向链表结点的数据类型。(1分)
//（）T （）F
//答案：T
//分析：可以快速查找下个结构体变量。
//
//选择题
//（3）在一个以 h 为头的单向链表中，p 指针指向链尾的条件是（）。(2分)
//
//A、p->next = h
//B、p->next = NULL
//C、p->next->next = h
//D、p->.data = -1
//答案：D
//分析：p指针指向链尾时是NULL，NULL = -1。
//
//（4）对于一个头指针为head的带头结点的单链表，判定该表为空表的条件（）。(2分)
//A、head == NULL
//B、head→next == NULL
//C、head→next == head
//D、head != NULL
//答案：B
//分析：head→next == NULL，next不指向任何结点，所以该表为空表。
//
//（5）下列算法创建n个元素的带头单链表
//typedef struct lnode
//{
//	int data;
//	struct lnode next;
//}lnode, linklist
//void create(linklist &head, int n)
//{
//	linklist p; int i;
//	head = (linklist)malloc(sizeof(lnode));
//	/ 此处选项() /
//		for (i = n; i>0; i–)
//		{
//		p = (linklist)malloc(sizeof(lnode));
//		scanf(“%d”, &p->data);
//		/ 此处选项() /
//			/ 此处选项() /
//		}
//}。(2分)
//A、head->next = null
//B、p->next = head->next
//C、head->next = p
//D、替换为错误项
//答案：C
//
//（6）在一个单链表head中，若要删除指针p所指结点的后继结点，则执行（）。(2分)
//A、p = p->next; free(p);
//B、p->next = p->next->next; free§;
//C、q = p->next q->next = p->next; free(q);
//D、q = p->next; p->next = q->next; free(q);
//答案：D
//
//（7）完成下列打印带头单链表的各元素的算法（）。
//typedef struct List
//{
//	int data;
//	struct List next;
//} Node，Link;
//void printlk(Link head)
//{
//	Link p = head->next;
//	while (（1）)
//	{
//		printf(“%d\n”, p->data);
//		（2）
//	}
//}(2分)
//A、p
//B、p = p->next
//C、p->next = p->next->next;
//D、free(p);
//答案：B
//
//（8）已知有如下C语言代码：(2分)
//struct node {
//	int val;
//	struct node *next;
//} p[3] = { 4, &p[2], 6, &p[0], 5, &p[1] };
//其中值为6的表达式是：
//A、p[1].next->val
//B、(&p[0])->next->val
//C、p[2].val
//D、p[2].next->val
//答案：D
//
//（9）下面程序段输入一行字符，按输入的逆序建立一个链表。
//struct node{
//	char info;
//	struct node *link;
//} *top, p;
//char c;
//top = NULL;
//while ((c = getchat()) != ’\n’)
//{
//	p = (struct node)malloc(sizeof(struct node));
//	p->info = c;
//	(1分);
//	top = p;
//}
//A、top->link = p
//B、p->link = top
//C、top = p->link
//D、p = top->link
//答案：B
//
//（10）关于单向链表说法不正确的是：(2分)
//A、与数据相比，单向链表适合反复进行删除、插入操作
//B、存储空间可以动态的获取和释放
//C、结点的存储空间分两部分，一部分用于存储结点的数据，另一部分用于存储其他结点的指针
//D、单向链表在内存中是连续存储的
//答案：D
//
//指针纠错
//判断题
//（1）函数名代表该函数的入口地址。因此，可用函数名给指向函数的指针变量赋值。(1分)
//（）T （）F
//答案：T
//分析：因为函数名就是一个地址，可以赋给指针。
//
//（2）结构体类型本身不占用内存空间，结构体变量占用内存空间。(1分)
//（）T （）F
//答案：T
//
//（3）在C语言中，逗号既可以作为运算符，也可以作为分隔符。(1分)
//（）T （）F
//答案：T
//
//（4）两指针变量相减所得之差是两个指针所指数组元素之间相差的元素个数。(1分)
//（）T （）F
//答案：T
//分析：指针变量相减所得之差就是两个数组元素的首地址的差值。
//
//选择题
//（5）以下不正确的赋值或赋初值的方式是()。(2分)
//A、char str[] = “string”;
//B、char str[7] = { ‘s’, ‘t’, ‘r’, ‘i’, ‘n’, ‘g’ };
//C、char str[10]；str = “string”;
//D、char str[7] = { ‘s’, ‘t’, ‘r’, ‘i’, ‘n’, ‘g’, ’\0’ };
//答案：C
//分析：str是一个地址，不能赋值。
//
//（6）以下能对一维数组a进行正确初始化的语句是()。(1分)
//A、int a[10] = (0, 0, 0, 0, 0)
//B、int a[2] = { 0, 1, 2 }
//C、int a[] = { 0 }
//D、int a[] = { {} }
//答案：C
//分析：A、数组初始化需要大括号；B、数组越界了；D、非法初始化。
//
//多选题
//（7）设变量已正确定义，以下（）是合法的C语句。(1分)
//A、if(n <= 10);
//
//B、switch(k) {
//case 1: printf(“one”); break;
//case 2: printf(“two”); break;
//case 1: printf(“one”); break;
//default: printf(“zero”); break;
//}
//
//C、switch(k % 2) {
//default: printf(“zero”); break;
//case 1: printf(“one”);
//case 1 + 1: printf(“two”);
//}
//
//D、n = 10;
//switch (k) {
//case n % 3: printf(“one”);
//case n % 4: printf(“two”);
//default: printf(“zero”);
//}
//答案：A、C
//分析：A、if(n <= 10); 符合if语句的定义；C、符合switch 的用法。
//
//（8）以下程序段（ ）的功能是求 s = 1 + 2 + … + n−1。(1分)
//A、int n = 10, s = 0;
//for (int i = 1; i < n; i++) {
//	s = s + i;
//}
//
//B、int n = 10, s = 0;
//for (int i = 1; i < n; ++i) {
//	s = s + i;
//}
//
//C、int n = 10, s = 0;
//for (int i = n - 1; i > 0; ++i) {
//	s = s + i;
//}
//
//D、int n = 10, s = 0;
//for (int i = 1; i <= n - 1; ++i) {
//	s = s + i;
//}
//
//E、int n = 10, s = 0;
//for (int i = n - 1; i > 0; i--) {
//	s = s + i;
//}
//答案：A、B、D、E
//
//填空题
//（9）下面程序可以逐行输出由language数组元素所指向的5个字符串。请填写程序中相应语句。
//#include<stdio.h>
//int main(void)
//{
//	char *language[] = { “BASIC”, “FORTRAN”, “PROLOG”, “JAVA”, “C++” };
//	char *q(2分);
//	int k;
//	for (k = 0; k < 5; k++) {
//		q = language[k];
//		printf("%s\n", *q);
//	}
//	return 0;
//}
//答案：**q；&language[k]
//分析：通过char *language[]，可以知道应该是一个二级指针 **q，所以可以得到后面是&language[k]。
//
//（10）若有定义double *p；请写出利用malloc函数使p指向一个双精度型的动态存储单元的完整语句为
//p = malloc(sizeof(double)); (1分)。
//答案：（double *）malloc(sizeof(double))
//
//（11）设有定义语句：int a[][3] = { { 0 }, { 1 }, { 2 } }; 则数组元素 a[1][2]的值是（0）(2分)
//答案：0
//
//（12）函数是一个完成特定工作的独立程序模块，包括 main函数(2分) 和 自定义函数 两种。
//答案：分库函数；自定义函数
//
//文件流纠错
//判断题
//（1）以“a”方式打开一个文件时，文件指针指向文件首。
//（）T （）F
//答案：：F
//
//单选题
//（2）定义FILE *fp; 则文件指针fp 指向的是（）。
//A、文件在磁盘上的读写位置
//B、文件在缓冲区上的读写位置
//C、整个磁盘文件
//D、文件类型结构体
//答案：
//
//（3）缓冲文件系统的文件缓冲区位于（）。
//A、磁盘缓冲区中
//B、磁盘文件中
//C、内存数据区中
//D、程序文件中
//答案：C
//
//（4）直接使文件指针重新定位到文件读写的首地址的函数是（） 。
//A、ftell()函数
//B、fseek()函数
//C、rewind()函数
//D、ferror()函数
//答案：C
//
//（5）按存储介质划分，文件可以分为：
//A、记录文件和流式文件
//B、普通文件和设备文件
//C、文本文件和二进制文件
//D、程序文件和数据文件
//答案：C
//
//（6）fputc(ch, fp) 把一个字符ch写到fp所指示的磁盘文件中，若写文件失败则函数的返回值为（ ）。
//A、0
//B、1
//C、EOF
//D、非0
//答案：C
//
//（7）函数fgetc的作用是从指定文件读入一个字符，该文件的打开方式必须是（ ）。
//A、只写
//B、追加
//C、读或读写
//D、答案B和C都正确
//答案：D
//
//（8）利用函数fseek可实现的操作是（ ）。
//A、改变文件指针fp的值
//B、文件的顺序读写
//C、文件的随机读写
//D、以上答案均正确
//答案：D
//
//（9）有一文本文件test.txt，其内容为"cprogram"（不包含引号），以下程序段的运行结果是（）。
//FILE *fp;
//char str[20];
//if ((fp = fopen(“test.txt”, “r”)) != NULL)
//str = fgets(str, 5, fp); printf("%s", str);
//
//A、cpro
//B、cprog
//C、prog
//D、cprogram
//答案：B
//
//多选题
//（10）设变量已正确定义，选项（ ）与以下程序段等价。
//
//switch (ch){
//case ‘ - ’:
//	minus++; break;
//case ‘0’: case ‘1’: case ‘2’: case ‘3’: case ‘4’:
//case ‘5’: case ‘6’: case ‘7’: case ‘8’: case ‘9’:
//	digit++; break;
//default:
//	other++; break;
//}
//
//A、if(ch == ‘ - ’){
//	minus++;
//}
//else if (ch >= ‘5’ && ch <= ‘9’){
//	digit++;
//}
//else {
//	other++;
//}
//
//B、switch(ch){
//default:
//	other++; break;
//case ‘ - ’:
//	minus++; break;
//case ‘0’: case ‘1’: case ‘2’: case ‘3’: case ‘4’:
//case ‘5’: case ‘6’: case ‘7’: case ‘8’: case ‘9’:
//	digit++; break;
//}
//
//C、if(ch == ‘ - ’){
//	minus++;
//}
//else if (ch >= ‘0’ && ch <= ‘9’){
//	digit++;
//}
//else {
//	other++;
//}
//
//D、switch(ch){
//case ‘0’: case ‘1’: case ‘2’: case ‘3’: case ‘4’:
//case ‘ - ’:
//	minus++; break;
//case ‘5’: case ‘6’: case ‘7’: case ‘8’: case ‘9’:
//	digit++; break;
//default:
//	other++; break;
//}
//答案：B、C
//分析：在B和C中如果ch为’ - '就minus++，如果是0~9就digit ++，如果是别的就other ++。它们与题目意思一样。
//
//（11）对于以下两个程序段，下列叙述正确的是（ ）。
//
//A、在程序段1和程序段2中，语句y = x + 1; 的执行条件皆为满足x<1。
//B、在程序段1和程序段2中，语句y = x + 1; 的执行条件皆为满足x<2。
//C、在程序段1中，语句y = x + 2; 的执行条件是满足x >= 2。
//D、在程序段1中，语句y = x + 2; 的执行条件是满足x >= 1且x<2。
//E、在程序段2中，语句y = x + 2; 的执行条件是满足x >= 2。
//F、在程序段2中，语句y = x + 2; 的执行条件是满足x >= 1且x<2。
/// *程序段1 * /
//if (x < 2){
//	if (x < 1){
//		y = x + 1;
//	}
//}
//else{
//	y = x + 2;
//}
/// *程序段2 * /
//if (x < 2){
//	if (x < 1){
//		y = x + 1;
//	}
//	else{
//		y = x + 2;
//	}
//}
//答案：A、F
//
//填空题
//（12）只能向指定文件写入一个字符的函数是 fgetc 。
//答案：fputc
//分析：
//
//（13）根据数据存储的编码形式，C语言中处理的数据文件通常为 文本文件
//文件和 二进制文件 文件两种。
//答案：文本；二进制
//
//（14）fgets(s, n, fp); 语句用来从fp所指示的文本文件中读取字符串s，该语句最多读取 n 个字符。
//答案：n - 1
//
//数组纠错
//判断题
//（1）数组名就是一个指针常量，指向数组的首元素（或者说代表了数组的首地址）。
//（）T （）F
//答案：F
//
//（2）在C语言中能逐个地使用下标变量，也能一次引用整个数组。
//（）T （）F
//答案：F
//
//（3）一维数组定义的一般形式如下，其中的类型名指定数组变量的类型。
//类型名 数组名[数组长度]；(1分)
//（）T （）F
//答案：F
//
//（4）数组定义后，只能引用单个的数组元素，而不能一次引用整个数组。
//（）T （）F
//答案：T
//
//单选题
//（5）假设scanf语句执行时输入ABCDE<回车>，能使puts(s)语句正确输出ABCDE字符串的程序段是__。(2分)
//A、char s[5] = { “ABCDE” }; puts(s);
//B、char s[5] = { ‘A’, ‘B’, ‘C’, ‘D’, ‘E’ }; puts(s);
//C、char * s; scanf("%s", s); puts(s);
//D、char *s; s = “ABCDE”; puts(s);
//答案：D
//
//（6）对于定义 char str[] = “abc\000def\n”（注：其中0为数字零），求字符串str的长度len和数组str的大小size，len和size分别是：(2分)
//A、12 ，13
//B、3 ，11
//C、3 ，9
//D、3 ，4
//答案：C
//
//（7）以下哪个定义中的p不是指针，请选择恰当的选项：(2分)
//A、char **p;
//B、char(*p)[10];
//C、char *p[6];
//D、给出的三项中，p都是指针
//答案：B
//
//（8）有两个字符数组a, b，则以下正确的输入语句是（）(1分)
//A、gets(a, b);
//B、scanf("%s%s", a, b);
//C、scanf("%s%s", &a, &b);
//D、gets(“a”), gets(“b”);
//答案：B
//
//多选题
//（9）如果变量定义如下，则正确的语句是（ ）。(1分)
//int k, a[10];
//
//A、a[-1] = -1;
//
//B、a[0] = 23;
//
//C、k = 3; a[k - 2] = a[9] + 1;
//
//D、for(k = 1; k <= 10; k++){
//	printf(“%d ”, a[k]);
//}
//
//E、for(k = 0; k < 10; k++){
//	scanf(“%d ”, &a[k]);
//}
//答案：B、C、E
//
//（9）在以下描述中，（ ）是正确的。(1分)
//
//A、int a[5] = { 1, 2, 3, 4, 5 };
//定义了数组a，并对数组元素赋初值。此时，a[0]为1，a[1]为2，a[2]为3，a[3]为4，a[4]为5。
//
//B、static int b[10];
//定义了静态数组b，且10个数组元素的初值都为0。
//
//C、int fib[45] = { 1, 1 };
//定义了数组fib，并对数组 fib 的前2个元素赋初值，其余元素的值都为0。
//
//D、static int week[7] = { 1, 2, 3 };
//定义了静态数组week，并对数组 week 的前3个元素week[0]～week[2]赋初值，week[3]～week[6]值都是不确定的
//答案：A、B、C
//
//（10）在以下描述中，（ ）是正确的。(1分)
//
//A、int a[3][3] = { 1 };
//定义了数组a，并对数组a赋初值。此时，a[0][0]的值为1，而其余元素的值都是不确定的。
//
//B、static int b[4][3] = { {}, {}, {}, { 9 } };
//定义了静态数组b，并对数组赋初值。此时，b[3][0]的值为9，而其余元素的值都为0。
//
//C、int a[3][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
//和
//int a[3][3] = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };
//等价。
//
//D、static int b[4][3] = { { 1, 2, 3 }, {}, { 4, 5 } };
//和
//static int b[4][3] = { 1, 2, 3, 0, 0, 0, 4, 5 };
//等价。
//
//E、int a[3][3] = { {}, { 4 }, {} };
//定义了数组a，并对数组a赋初值。此时，a[1][1]的值为4，而其余元素的值都是不确定的。
//答案：B、C、D
//
//（11）选项（ ）与以下字符数组定义等价。(1分)
//
//static char s[6] = { ‘H’, ‘a’, ‘p’, ‘p’, ‘y’, ‘\0’ };
//
//A、static char s[6] = { ‘H’, ‘a’, ‘p’, ‘p’, ‘y’ };
//
//B、static char s[6] = “Happy”;
//
//C、static char s[6] = { “Happy” };
//
//D、static char s[6] = { ‘H’, ‘a’, ‘p’, ‘p’, ‘y’, 0 };
//答案：A、B、C、D
//————————————————
//版权声明：本文为CSDN博主「子~木」的原创文章，遵循CC 4.0 BY - SA版权协议，转载请附上原文出处链接及本声明。
//原文链接：https ://blog.csdn.net/li_lhj/article/details/103763680